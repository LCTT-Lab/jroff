<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>jroff.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Token.html">Token</a></li></ul><h3>Namespaces</h3><ul><li><a href="patterns.html">patterns</a></li></ul><h3>Global</h3><ul><li><a href="global.html#IMACRO">IMACRO</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">jroff.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @license
 * Jroff 0.0.1 &lt;http://roperzh.github.io/jroff.js>
 * Copyright (c)2015 Roberto Dip &lt;http://roperzh.com>
 * Distributed under MIT license
 */



/**
 * Creates a new instance of class Token.
 * @class
 * @property value {string} the value of the token
 * @property kind {number} the kind of the token
 */
var Token = function (value, kind) {
  this.value = value || '';
  this.kind = kind || EMPTY;
  this.nodes = [];
};

//--------- Public methods

Token.prototype.mix = function (token) {
  this.value = this.value + ' ' + token.value;

  if(this.kind === EMPTY) {
    this.kind = token.kind;
  }

  return this;
};

Token.prototype.addNode = function (token) {
  this.nodes.push(token);

  return this;
};

Token.prototype.lastNode = function () {
  return this.nodes[this.nodes.length - 1] || new Token();
};

Token.prototype.mixWithLastNode = function (token) {
  this.lastNode()
    .mix(token);
};

Token.prototype.addSubNode = function (token) {
  this.lastNode()
    .addNode(token);
};

//--------- Class methods

Token.isMacro = function (str) {
  return patterns.macro.test(str);
};

Token.isInlineMacro = function (str) {
  return Boolean(macros[str]);
};

Token.isComment = function (str) {
  return patterns.comment.test(str);
};

Token.isEmptyLine = function (str) {
  return str === '\n';
};
var TokenFactory = function () {};

TokenFactory.prototype.create = function (rawToken) {
  var kind = TEXT;

  if(Token.isComment(rawToken)) {
    kind = COMMENT;
  } else if(Token.isMacro(rawToken)) {
    kind = MACRO;
    rawToken = rawToken.substring(1);
  } else if(Token.isInlineMacro(rawToken)) {
    kind = IMACRO;
  } else if(Token.isEmptyLine(rawToken)) {
    kind = BREAK;
  } else {
    kind = TEXT;
  }

  return new Token(rawToken, kind);
};
var Lexer = function (source) {
  this.source = source.match(patterns.noWithespace);
  this.tokens = [];
  this.sourceIdx = 0;
  this.col = 0;
  this.line = 0;
  this.factory = new TokenFactory();
};

Lexer.prototype.lex = function () {
  var token;

  while((token = this.next())) {
    this.tokens.push(this.factory.create(token));
  }

  return this.tokens;
};

Lexer.prototype.next = function () {
  return this.source[this.sourceIdx++];
};
var Parser = function (input) {
  this.ast = [];
  this.lexer = new Lexer(input);
  this.tokens = this.lexer.lex();
  this.tokenslen = this.tokens.length;
  this.idx = 0;
  this.state = BREAK;

  /* beautify ignore:start */

  var mappings = [

    // COMMENT mappings
    { state: COMMENT, input: '*',     action: 'ignore'       },
    { state: COMMENT, input: BREAK,   action: 'stop'         },

    // MACRO mappings
    { state: MACRO,   input: BREAK,   action: 'stop'         },
    { state: MACRO,   input: TEXT,    action: 'addText'      },
    { state: MACRO,   input: IMACRO,  action: 'addInline'    },
    { state: MACRO,   input: COMMENT, action: 'ignore'       },
    { state: MACRO,   input: MACRO,   action: 'addText'      },

    // IMACRO mappings
    { state: IMACRO,  input: TEXT,    action: 'addImacro'    },
    { state: IMACRO,  input: IMACRO,  action: 'addImacro'    },
    { state: IMACRO,  input: '*',     action: 'defaultError' },

    // BREAK mappings
    { state: BREAK,   input: MACRO,   action: 'startMacro'   },
    { state: BREAK,   input: BREAK,   action: 'addLineBreak' },
    { state: BREAK,   input: '*',     action: 'cleanBreak'   },

    // TEXT mappings
    { state: TEXT,    input: MACRO,   action: 'addText'      },
    { state: TEXT,    input: COMMENT, action: 'ignore'       },
    { state: TEXT,    input: TEXT,    action: 'addText'      },
    { state: TEXT,    input: BREAK,   action: 'stop'         }
  ];

  /* beautify ignore:end */

  this.initMappings = function () {
    var mapping,
      actionName;

    for(var i = mappings.length - 1; i >= 0; i--) {
      mapping = mappings[i];
      actionName = mapping.state + '-' + mapping.input;

      if(!this[mapping.action]) {
        throw(
          'Undefined function ' + mapping.action + ' in Parser object'
        );
      }

      this[actionName] = this[mapping.action].bind(this);
    }
  };

  this.lastTok = function () {
    return this.ast[this.ast.length - 1];
  };

  this.initMappings();
};

Parser.prototype.cleanBreak = function (token) {
  this.state = token.kind;
};

Parser.prototype.ignore = function () {
  this.state = COMMENT;
};

Parser.prototype.startMacro = function (token) {
  this.state = MACRO;
  this.ast.push(token);
};

Parser.prototype.stop = function (token) {
  this.ast.push(token);
  this.state = BREAK;
};

Parser.prototype.addText = function (token) {
  var lastToken = this.lastTok();

  if(lastToken.lastNode()
    .kind === TEXT) {
    lastToken.mixWithLastNode(token);
  } else {
    lastToken.addNode(token);
  }
};

Parser.prototype.addInline = function (token) {
  this.state = IMACRO;
  this.lastTok()
    .addNode(token);
};

Parser.prototype.addImacro = function (token) {
  this.state = MACRO;
  this.lastTok()
    .addSubNode(token);
};

Parser.prototype.addLineBreak = function (token) {
  this.ast.push(token);
};

Parser.prototype.defaultError = function (token) {
  throw(
    'Error parsing argument with state: ' +
    this.state + ', input: ' + token.kind
  );
};

Parser.prototype.buildAST = function () {
  var token,
    funcName,
    func;

  while(this.tokenslen > this.idx) {
    token = this.tokens[this.idx];
    funcName = this.state + '-' + token.kind;
    func = this[funcName] || this[this.state + '-*'];

    if(!func) {
      throw(
        'Cannot find a function named ' +
        funcName + ' or ' + this.state + '-*'
      );
    }

    func(token);
    this.idx++;
  }

  return this.ast;
};

var debug = function (arr) {
  return arr.reduce(function (result, node) {
    if(node.nodes.length) {
      var f = macros[node.value] || function () {
        console.warn('warn: undefined macro ' + node.value);
        return node.value;
      };

      result += f(debug(node.nodes));
    } else {
      result += node.value;
    }

    return result;
  }, '');
};

/**
 * @constant COMMENT {number}
 * @constant MACRO {number}
 * @constant IMACRO {number}
 */

var COMMENT = 1;
  MACRO = 2,
  IMACRO = 3,
  BREAK = 4,
  TEXT = 5,
  EMPTY = 6;

/**
 * @namespace
 */

var patterns = {
  macro: /^\./,
  noWithespace: /\n|\S+/g,
  comment: /(\.\\)?\\\"/
};
  return {
    Lexer: Lexer,
    Token: Token,
    TokenFactory: TokenFactory,
    macros: macros,
    patterns: patterns,
    Parser: Parser,
    debug: debug,
    COMMENT: COMMENT,
    MACRO: MACRO,
    IMACRO: IMACRO,
    BREAK: BREAK,
    TEXT: TEXT,
    EMPTY: EMPTY
  };
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed Nov 18 2015 22:57:58 GMT-0300 (ART) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
